# -*- coding: utf-8 -*-
"""func.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Eq-WQ8Q_iRgZekfxiZ9LP8UVfkYGk2YX
"""

from google.colab import drive
drive.mount('/content/drive')
import pandas as pd
import numpy as np
from sklearn.linear_model import LogisticRegression
import math
import csv

def read_MS(f):
  '''
  transpose data from a sample
  '''
  df = pd.read_csv(f)
  df = df.T
  df.columns = df.iloc[0]
  df = df.iloc[1:,:]
  return(df)

def subset_by_mz (df, feat):
  '''
  subset data by feature, return a dataframe with # sel feat. columns
  '''
  df_feat = df[feat]
  return(df_feat)

def logistic_regression(df_feat, label):
  '''
  among all samples, obtain and scale beta values [-1,1]
  '''
  clf = LogisticRegression(random_state=np.random.seed(10),max_iter=5000).fit(df_feat, label)
  scaled_coef = [] # beta
  max_coef = np.max(abs(clf.coef_))
  for b in clf.coef_:
    scaled_b = b/max_coef
    scaled_coef.append(scaled_b)
  return(scaled_coef[0])

def scale_intensities(df_feat):
  '''
  for each sample, scale intensities
  '''
  df_sc = df_feat
  for i in range(len(df_feat.columns)):
    min = df_feat.iloc[:,i].min()
    max = df_feat.iloc[:,i].max()
    for j in range(len(df_feat.index)):
      df_sc.iloc[j,i] = (df_feat.iloc[j,i]-min)/(max-min)
  return(df_sc)

def risk_score(df_feat, b):
  '''
  for each sample, calculate risk score for each pixel
  df_feat is a dataframe from one subsetted sample with # sel feat. cols
  b is an array of logistic regression coefficients
  '''
  risk = []
  for i in range(len(df_feat.index)):
    part_risk = 0
    for j in range(len(df_feat.columns)):
      part_risk += df_feat.iloc[i,j]*math.exp(b[j])
    risk.append(part_risk)
  return(risk)

def normalize_0_1(r):
  '''
  scale risk scores between 0-1
  '''
  return (r - np.min(r)) / (np.max(r) - np.min(r))

def retrieve_location (f, col, TN):
  """
  coords are stored and retrieved from 'coords.csv' by file name
  pixel is identified by col
  TN indicates tumor or normal
  """
  if(TN=='T'):
    f = './'+f[50:]
  else:
    f = './'+f[51:]
  reader = csv.reader(open('/content/drive/My Drive/CS539/proj/data/coords.csv', 'r'))
  d = {}
  for row in reader:
    fn, X, Y = row
    d[fn] = (X,Y)
  # get largest x and y
  X = int(d[f][0])
  Y = int(d[f][1])
  if (col%X == 0):
    x = X  
  else:
    x = col%X
  y = int(np.ceil(col/X))
  return x,y

def fit_calc_score(f, feature, b, TN):
  '''
  f: file name
  feature: common m/z values selected from ML models
  b: logistic regression coefficients calc. based on all subsetted datasets
  TN: 'T' for tumor, 'N' for normal
  create a dataframe contains columns x, y, sc
  '''
  df = read_MS(f)
  df = subset_by_mz(df, feature)
  r = risk_score(df,b)
  r = normalize_0_1(r)
  coords = []
  for i in range(1,len(r)+1):
    coords.append(retrieve_location(f, i,TN))
  xcoord = []
  ycoord = []
  for x,y in coords:
    xcoord.append(x)
    ycoord.append(y)
  d = {'x': xcoord, 'y': ycoord, 'sc': r}
  x_y_sc = pd.DataFrame(d)
  return(x_y_sc)